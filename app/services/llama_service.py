import os
import xml.etree.ElementTree as ET # A library used to parse XML filews
from groq import Groq
from typing import List, Dict, Any, Optional # This library is used to define types for the functions
from dotenv import load_dotenv

# Loading environment the environment variable
load_dotenv()

# Initalizing the groq client
api_key = os.getenv('Llama_API_KEY')
client = Groq(api_key=api_key)

# A function to analyze the vulnerabilities in the XML report
def analyze_vulnerabilities(xml_report: str) -> Dict[str, Any]: # This means that the function takes the path to the xml report(string) as an argument and returns a dictionary containing the results of the analysis
    try:
        # Parsing the XML report
        tree = ET.parse(xml_report) # The xml report is parsed and stored in the tree variable
        root = tree.getroot() # The root of the XML tree is retrieved and stored in the root variable

        # Extracting the vulnerabilities from the report
        vulnerabilities = [] # A list for storing the vulnerabilities
        for site in root.findall(".//site"): # Iterating over all the sites in the XML report
            for alert in site.findall(".//alert"): # Iterating over all the alerts in the XML report
                vulnerability = {
                   'name': get_element_text(alert, 'name'),
                   'risk': get_element_text(alert, 'riskdesc'), # risckdesc is the risk level of the vulnerability
                   'description': get_element_text(alert, 'desc'), # desc is the description of the vulnerability
                   'solution': get_element_text(alert, 'solution'), # solution is the possible solution to the vulnerability 
                   'reference': get_element_text(alert, 'reference'), # A reference link for the vulnerability
                   'instances': []
                }
                # Extracting the instances of the vulnerabailty
                for instance in alert.findall(".//instance"): # Iterating over all the instances of the vulnerability
                    vulnerability['instances'].append({
                        'url': get_element_text(instance, 'uri'), # Adding the url of the instance to the list
                        'method': get_element_text(instance, 'method'), # Adding the method of the instance to the list
                        'evidence': get_element_text(instance,'evidence'), # Adding the evidence to the list
                    })
                vulnerabilities.append(vulnerability) # Adding the vulnerability to the vulnerabailites list
        

        prompt = format_vulnerability_prompt(vulnerabilities, xml_report)
        # Sending the prompt to the llama model
        completion = client.chat.completions.create(
            model = "meta-llama/llama-4-scout-17b-16e-instruct", # This is the model used
            messages=[
                {
                    "role": "user",
                    "content": prompt # Here I pass the prompt to the model
                }
            ]
        )

        # To Extract the response
        response = completion.choices[0].message.content 
        
        # Getting the base name of the xml report without the extension
        base_name = os.path.splitext(os.path.basename(xml_report))[0] 
        response_file_name = base_name + ".md"
        
        # Ensuring that the output directory exists
        output_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "reports", "outputs")
        os.makedirs(output_dir, exist_ok=True)
        
        # Saving the response to a file
        response_output_path = os.path.join(output_dir, response_file_name)
        with open(response_output_path, "w") as f:
            f.write(response)

        return {
            "success": True,
            "response": response,
            "vulnerabilities": vulnerabilities
        }
        
    except Exception as e:
        return {
            "success": False,
            "error": str(e)
        }


# I made this function to format the vunerability data into a prompt for the llma model and also to have the prompt that Im going to use
def format_vulnerability_prompt(vulnerabilities: list, xml_report: str) -> str:

    prompt = '''You are a cybersecurity-savvy technical writer. Your task is to reformat and enhance a vulnerability scanning report generated by OWASP ZAP. The report includes a list of alerts categorized by severity and detailed information about each alert.

**Objectives:**
1. Translate technical descriptions into clear, understandable language for a broader audience (e.g., developers, managers).
2. Preserve all essential technical details (risk level, URLs, attack vectors, evidence, and solutions).
3. Organize the output into an elegant, readable format (markdown or HTML), with sections for:
   - Executive Summary
   - Vulnerability Overview by Severity
   - Detailed Findings
   - Recommended Actions
   - Glossary
4. Style and format it in a modern, minimal report design, similar to a consulting security assessment (white-label report).
5. Make sure to mantain the same urls as in the original report.

**Context for this Project:**
This report is part of an automated penetration testing tool that integrates OWASP ZAP with AI to generate more digestible security reports. The goal is to help non-experts understand vulnerabilities and fix them.

Here is the extracted vulnerability data from the ZAP scan:
'''

    # Adding the vulnerability data to the prompt
    prompt += "\n### Vulnerability Data \n"

    # Iterating over the vulnerabilities, "enumerate" is a function that returns a tuple containing a count (starting from 0 by default) and the values obtained from iterating over the sequence
    # "enumerate(vulnerabilities, 1)" means that the count will start from 1 instead of 0
    for i, vulnerability in enumerate(vulnerabilities, 1):
        prompt += f"\nVulnerability {i}: {vulnerability.get('name', 'Unknown')}\n"
        prompt += f"- Risk Level: {vulnerability.get('risk', 'Unknown')}\n"
        prompt += f"- Description: {vulnerability.get('description', 'Unknown')}\n"
        prompt += f"- Solution: {vulnerability.get('solution', 'Unknown')}\n"

        # Adding the instances to the prompt
        instances = vulnerability.get('instances', []) # Getting the instances of the vulnerability , an empty list is returned if the instances are not found
        
        if instances:
            prompt += "\n -Instances:\n"
            # Iterating over the instances to add them to the prompt
            for j, instance in enumerate(instances, 1):
                prompt += f"  Instance {j}:\n"
                prompt += f"  - URL: {instance.get('url', 'Unknown')}\n"
                prompt += f"  - Method: {instance.get('method', 'Unknown')}\n"
                prompt += f"  - Evidence: {instance.get('evidence', 'Unknown')}\n"
        
        # Adding a separator between the vulnerabilities
        if i < len(vulnerabilities):
            prompt += "\n---\n"

        prompt += "\n\nPlease return the output as markdown suitable for use on a webpage or as a downloadable PDF. Format your response as clean markdown without any additional commentary."

    return prompt

# Helper function to safely extract the text from the XML elements
def get_element_text(element, tag_name: str) -> str:
    child = element.find(tag_name)
    if child is not None and child.text:
        return child.text
    else:
        return ""