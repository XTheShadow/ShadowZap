import os
import xml.etree.ElementTree as ET # A library used to parse XML filews
from groq import Groq
from typing import List, Dict, Any # This library is used to define types for the functions

# Initalizing the groq client
api_key = os.getenv('LlIMA_API_KEY')
client = Groq(api_key=api_key)

# A function to analyze the vulnerabilities in the XML report
def analyze_vulnerabilities(xml_report: str) -> Dict[str, Any]: # This means that the function takes the path to the xml report(string) as an argument and returns a dictionary containing the results of the analysis
    try:
        # Parsing the XML report
        tree = ET.parse(xml_report) # The xml report is parsed and stored in the tree variable
        root = tree.getroot() # The root of the XML tree is retrieved and stored in the root variable

        # Extracting the vulnerabilities from the report
        vulnerabilities = [] # A list for storing the vulnerabilities
        for site in root.findall(".//site"): # Iterating over all the sites in the XML report
            for alert in site.findall(".//alert"): # Iterating over all the alerts in the XML report
                vulnerability = {
                   'name': get_element_text(alert, 'name'),
                   'risk': get_element_text(alert, 'riskdesc'), # risckdesc is the risk level of the vulnerability
                   'description': get_element_text(alert, 'desc'), # desc is the description of the vulnerability
                   'solution': get_element_text(alert, 'solution'), # solution is the possible solution to the vulnerability 
                   'reference': get_element_text(alert, 'reference'), # A reference link for the vulnerability
                   'instances': []
                }
                # Extracting the instances of the vulnerabailty
                for instance in alert.findall(".//instance"): # Iterating over all the instances of the vulnerability
                    vulnerability['instances'].append({
                        'url': get_element_text(instance, 'uri'), # Adding the url of the instance to the list
                        'method': get_element_text(instance, 'method'), # Adding the method of the instance to the list
                        'evidence': get_element_text(instance,'evidence'), # Adding the evidence to the list
                    })
                vulnerabilities.append(vulnerability) # Adding the vulnerability to the vulnerabailites list
        

        prompt = format_vulnerability_prompt(vulnerabilities)
        # Sending the prompt to the llama model
        completion = client.chat.completions.create(
            model = "meta-llama/llama-4-scout-17b-16e-instruct", # This is the model used
            messages=[
                {
                    "role": "user",
                    "content": prompt # Here I pass the prompt to the model
                }
            ]
        )

        # To Extract the response
        response = completion.choices[0].message.content 

        return {
            "success": True,
            "response": response,
            "vulnerabilities": vulnerabilities
        }
        
    except Exception as e:
        return {
            "success": False,
            "error": str(e)
        }


# I made this function to format the vunerability data into a prompt for the llma model and also to have the prompt that Im going to use
def format_vulnerability_prompt(vulnerability: list) -> str:

    prompt = '''You are a cybersecurity-savvy technical writer. Your task is to reformat and enhance a vulnerability scanning report generated by OWASP ZAP. The report includes a list of alerts categorized by severity and detailed information about each alert.

**Objectives:**
1. Translate technical descriptions into clear, understandable language for a broader audience (e.g., developers, managers).
2. Preserve all essential technical details (risk level, URLs, attack vectors, evidence, and solutions).
3. Organize the output into an elegant, readable format (markdown or HTML), with sections for:
   - Executive Summary
   - Vulnerability Overview by Severity
   - Detailed Findings
   - Recommended Actions
   - Glossary
4. Style and format it in a modern, minimal report design, similar to a consulting security assessment (white-label report).

**Context for this Project:**
This report is part of an automated penetration testing tool that integrates OWASP ZAP with AI to generate more digestible security reports. The goal is to help non-experts understand vulnerabilities and fix them.

Here is the extracted vulnerability data from the ZAP scan:
'''

    # Adding the vulnerability data to the prompt
    prompt += "\n### Vulnerability Data \n"

    # Iterating over the vulnerabilities, "enumerate" is a function that returns a tuple containing a count (starting from 0 by default) and the values obtained from iterating over the sequence
    # "enumerate(vulnerabilities, 1)" means that the count will start from 1 instead of 0
    for i, vulnerability in enumerate(vulnerabilities, 1):
        prompt += f"\nVulnerability {i}: {vulnerability.get('name', 'Unknown')}\n"
        prompt += f"- Risk Level: {vulnerability.get('risk', 'Unknown')}\n"
        prompt += f"- Description: {vulnerability.get('description', 'Unknown')}\n"
        prompt += f"- Solution: {vulnerability.get('solution', 'Unknown')}\n"

        # Adding the instances to the prompt
        instances = vulnerability.get('instances', []) # Getting the instances of the vulnerability , an empty list is returned if the instances are not found
        
        if instances:
            prompt += "\n -Instances:\n"
            # Iterating over the instances to add them to the prompt
            for j, instance in enumerate(instances, 1):
                prompt += f"  Instance {j}:\n"
                prompt += f"  - URL: {instance.get('url', 'Unknown')}\n"
                prompt += f"  - Method: {instance.get('method', 'Unknown')}\n"
                prompt += f"  - Evidence: {instance.get('evidence', 'Unknown')}\n"
        
        # Adding a separator between the vulnerabilities
        if i < len(vulnerabilities):
            prompt += "\n---\n"

        prompt += "\n\nPlease return the output as markdown suitable for use on a webpage or as a downlaodable PDF."

    return prompt